---
title: 设计模式-总体介绍
comments: true
date: 2017-08-31 19:00:38
tags: [编程思想,设计模式]
categories: 设计模式
---
## 1 总体介绍

### 1.1 什么是设计模式

{% note info %} 
每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。- Christopher Alexander 
{% endnote %}

{% note info %} 
对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。- GoF
{% endnote %}

四个基本要素：

1. **模式名称（pattern name）** 一个助记名，它用一两个词来描述模式的问题、解决方案和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一。
2. **问题(problem)** 描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。
3. **解决方案(solution)** 描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。
4. **效果(consequences)** 描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。

<!--more-->

### 1.2 描述设计模式

- **模式名和分类**模式名简洁地描述了模式的本质。
- **意图**是回答下列问题的简单陈述：设计模式是做什么的？它的基本原理和意图是什么？它解决的是什么样的特定设计问题？
- **别名**模式的其他名称。
- **动机**用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。
- **适用性**什么情况下可以使用该设计模式？该模式可用来改进哪些不良设计？你怎样识别这些情况？
- **结构**采用基于对象建模技术的表示法对模式中的类进行图形描述。
- **参与者**指设计模式中的类和/或对象以及它们各自的职责。
- **协作**模式的参与者怎样协作以实现它们的职责。
- **效果**模式怎样支持它的目标？使用模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？
- **实现**实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于实现语言的问题。
- **代码示例**实现该模式的代码片段。
- **已知应用**实际系统中发现的模式的例子。
- **相关模式**与这个模式紧密相关的模式有哪些？其间重要的不同之处是什么？这个模式应与哪些其他模式一起使用？

### 1.3 设计模式怎样解决设计问题

1. **寻找合适的对象**
2. **决定对象的粒度**
3. **指定对象接口**
4. **描述对象的实现**
5. **运用复用机制**
6. **关联运行时刻和编译时刻**
7. **设计应支持变化**

### 1.4 导致重新设计的一般原因，以及解决这些问题的设计模式

1. **通过显式地指定一个类来创建对象**在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。
设计模式：Abstract Factory， Factory Method，Prototype。
2. **对特殊操作的依赖** 当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。
设计模式：Chain of Resposibility，Command。
3. **对硬件和软件平台的依赖** 外部的操作系统接口和应用编程接口(API)在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。
设计模式：Abstract Factory， Bridge。
4. **对对象表示或实现的依赖**知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。
设计模式：Abstract Factory，Bridge，Memento，Proxy
5. **算法依赖** 算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。
设计模式：Builder，Iterator，Strategy，Template Method，Visitor
6. **紧耦合** 紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。
设计模式：Abstract Factory，Command，Facade，Mediator，Observer，Chain of Responsibility。
7. **通过生成子类来扩充功能** 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等 )。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。
设计模式：Bridge，Chain of Responsibility，Composite，Decorator，Observer，Strategy。
8. **不能方便地对类进行修改** 有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况 )，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。
设计模式：Adapter，Decorator，Visitor。

### 1.5 怎样选择设计模式

- 考虑设计模式是怎样解决设计问题的
- 浏览模式的意图部分 
- 研究模式怎样互相关联 
- 研究目的相似的模式 
- 检查重新设计的原因
- 考虑你的设计中哪些是可变的 

### 1.6 怎样使用设计模式

1. **大致浏览一遍模式**特别注意其适用性部分和效果部分，确定它适合你的问题。
2. **回头研究结构部分、参与者部分和协作部分**确保你理解这个模式的类和对象以及它们是怎样关联的。
3. **看代码示例部分，看看这个模式代码形式的具体例子**研究代码将有助于你实现模式。
4. **选择模式参与者的名字，使它们在应用上下文中有意义**设计模式参与者的名字通常过于抽象而不会直接出现在应用中。然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显式的体现出模式来。例如，如果你在文本组合算法中使用了 Strategy 模式，那么你可能有名为 SimpleLayout Strategy 或 TeX Layout Strategy 这样的类。
5. **定义类**声明它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。识别模式会影响到的你的应用中存在的类，做出相应的修改。
6. **定义模式中专用于应用的操作名称**这里再一次体现出，名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导。还有，你的名字约定要一致。例如，可以使用“Create-”前缀统一标记 Factory 方法。
7. **实现执行模式中责任和协作的操作**实现部分提供线索指导你进行实现。代码示例部分的例子也能提供帮助。

## 2 目录

按目的准则（即模式是用来完成什么工作）分类：
*注*：第二个（）表示范围准则，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。

### 2.1 创建型

创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。

#### 2.1.1 [抽象工厂（Abstract Factory）（对象）]()

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

#### 2.1.2 [建造者（Builder）（对象）]()

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

#### 2.1.3 [工厂方法（Factory Method）（类）]()

定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method 使一个类的实例化延迟到其子类。

#### 2.1.4 [原型（Prototype）（对象）]()

用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

#### 2.1.5 [单例（Singleton）（对象）]()

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 2.2 结构型

结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。

#### 2.2.1 [适配器（Adapter）（类、对象）]()

将一个类的接口转换成客户希望的另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

#### 2.2.2 [桥接（Bridge）（对象）]()

将抽象部分与它的实现部分分离，使它们都可以独立地变化。

#### 2.2.3 [组合（Composite）（对象）]()

将对象组合成树形结构以表示“部分 -整体”的层次结构。 Composite 使得客户对单个对象和复合对象的使用具有一致性。

#### 2.2.4 [装饰者（Decorator）（对象）]()

动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活。

#### 2.2.5 [外观（Facade）（对象）]()

为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### 2.2.6 [享元（Flyweight）（对象）]()

运用共享技术有效地支持大量细粒度的对象

#### 2.2.7 [代理（Proxy）（对象）]()

为其他对象提供一个代理以控制对这个对象的访问。

### 2.3 行为型

行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。

#### 2.3.1 [责任链（Chain of Responsibility）（对象）]()

为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

#### 2.3.2 [命令（Command）（对象）]()

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

#### 2.3.3 [解释器（Interpreter）（类）]()

给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

#### 2.3.4 [迭代器（Iterator）（对象）]()

提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。

#### 2.3.5 [中介者（Mediator）（对象）]()

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

#### 2.3.6 [备忘录（Memento）（对象）]()

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态

#### 2.3.7 [观察者（Observer）（对象）]()

定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。

#### 2.3.8 [状态（State）（对象）]()

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

#### 2.3.9 [策略（Strategy）（对象）]()

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。

#### 2.3.10 [模板方法（Template Method）（类）]()

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

#### 2.3.11 [访问者（Visitor）（对象）]()

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## 3 设计模式相关图表

![设计模式关系图](/images/posts/设计模式关系图.jpg)
![设计模式可变性](/images/posts/设计模式可变性.jpg)

## 参考文章

1 设计模式 - 可复用面向对象软件的基础（第一章：引言）